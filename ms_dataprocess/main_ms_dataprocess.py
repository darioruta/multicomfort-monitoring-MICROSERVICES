import cherrypy
import cherrypy_cors
import pandas as pd
import threading
from data_process import ComfortCalculator
import json
from logging import raiseExceptions
import defines.define_URIs_service_catalog as deMicroServices
from defines.defineJSONVariables import de as deJSONVar 
import time
from data_process import ComfortCalculator, FlaskApp

from influxdb_client import InfluxDBClient, Point, WritePrecision
from influxdb_client.client.write_api import SYNCHRONOUS
import os
from datetime import datetime
import numpy as np

import paho.mqtt.client as mqtt
import random

# import json variable names under the variable de
de = deJSONVar()

# import json variable names under the variable de
deMS =  deMicroServices.de_microservices()

# il cloud é l'insieme di dati (misurazioni) salvati e disponibili nel tempo
class WriteCloud_InfluxDB:
	def __init__(self, url, token, org):
		self.influxDB_url = url
		self.influxDB_token = token
		self.influxDB_org = org
		self.client = InfluxDBClient(url=self.influxDB_url, token=self.influxDB_token, org=self.influxDB_org, verify_ssl=False, username="ict4bd2", password="YZ5du3XqU$")


	def addMeasurement(self, bucket, name_point, fields = [], tags = [], timestamp =None ):
		if timestamp == None:
			timestamp = datetime.now()

		point = Point(name_point)
		if type(tags) == list:
			for k,v in tags:
				point.tag(k,v) 
		if type(fields) == list:
			for k, v in fields:
				point.field(k,float(v)) 
		elif type(fields) == dict:
			for k, v in fields.items():
				point.field(k,float(v)) 
		else: pass
		
		#point.time(timestamp)
		#point.time(int((datetime.now().timestamp()-5)))
		#point.time(int(datetime.strptime('2023-05-13', '%Y-%m-%d').timestamp()))

		write_api = self.client.write_api(write_options=SYNCHRONOUS)
		write_api.write(bucket, self.influxDB_org, point)
		
		print("Aggiunta misurazione:")
		if type(fields) == list:
			for k, v in fields:
				print(f"\t t: {timestamp}, {k}: {v}")
		elif type(fields) == dict:
			for k, v in fields.items():
				print(f"\t t: {timestamp}, {k}: {v}")
		else: pass
		print()


class DataProcess:
	exposed = True
	# http://127.0.0.1:8088/set_status?state=1    -> per attivare il dataprocess in background

	def __init__(self,time_interval = 30, settings = {}):    # time interval viene usato questo valore di default
		self.time_interval = time_interval
		self.process_is_on = False
		self.process_base_is_on = False
		self.process_kpi_is_on = False

		self.client = mqtt.Client()
		self.client.connect("test.mosquitto.org", 1883)
		self.topic = "testing_nano_ip_project_LED_status"
		
		self.uris_available = deMS.show_allUris()
		# old token influxDB_settings[de.influxDB_token]
		self.wr_cat_influxDB = WriteCloud_InfluxDB(url=setting["influxDB_url"], token=os.getenv(setting["influxDB_token"]), org=setting["influxDB_org"])

		self.autoGenerateData = threading.Thread(target=self.Dummy_Process, name=setting[de.name])
		#self.autoGenerateData.start()
		# TODO: rimettere questi nel main (cancella)
		self.autoGenerateData = threading.Thread(
			target=self.Process_KPI, name=setting[de.name])
		self.autoGenerateData.start()

		self.flask = FlaskApp()
		self.autoFlaskData = threading.Thread(
			target=self.flask.run(), name='flask_app')
		self.autoFlaskData.start()


	def Download_last_sample(self, kitID, fields):
		# PRIMA SEZIONE PER REGISTRARSI AL CATALOGO
		try:
			bucket = de.bucket_Io3_raw_data
			#bucket = de.bucket_Io3_Test1
			print(f"Leggo le misurazioni - {bucket}:")
			# inizializzo struttura dati locale da ritornare a Dario
			data = {}
			for field in fields:
				data[field] = "ERROR"

			query = f'from(bucket: "{bucket}")  |> range(start: -30d)|> filter(fn: (r) => r.kitID == "{kitID}")|> last()'
			tables = self.wr_cat_influxDB.client.query_api().query(
				query, org=self.wr_cat_influxDB.influxDB_org)

			for table in tables:
				for record in table.records:
					if record["_field"] in fields:
						#data[record["_field"]].append(record["_value"])
						data[record["_field"]] = round(record["_value"], 2)
			print(data)
			return data
		except:
			print(f"Download data FAILED")
			raiseExceptions(f"Download data FAILED")

	def Download_time_series(self, kitID, fields, range_start=None,bucket = de.bucket_Io3_raw_data):
		if range_start == None:
			range_start = f"-{self.time_interval}s"

		# PRIMA SEZIONE PER REGISTRARSI AL CATALOGO
		try:
			#bucket = de.bucket_Io3_raw_data
			print(f"Leggo le misurazioni - {bucket}:")
			# inizializzo struttura dati locale da ritornare a Dario
			data = {}
			for field in fields:
				data[field] = []

			query = f'from(bucket: "{bucket}")  |> range(start: {range_start})|> filter(fn: (r) => r.kitID == "{kitID}")'
			tables = self.wr_cat_influxDB.client.query_api().query(
				query, org=self.wr_cat_influxDB.influxDB_org)

			for table in tables:
				for record in table.records:
					if record["_field"] in fields:
						data[record["_field"]].append([str(record["_time"]),round(record["_value"],2)])
			print(data)
			return data
		except:
			print(f"Download data FAILED")
			raiseExceptions(f"Download data FAILED")


	def addMeasurements_InfluxDB(self, fields, tags=[], name_point = de.kitID, bucket = de.bucket_Io3_raw_data, timestamp = None):
		if timestamp == None:
			timestamp = datetime.now()
		try:
			self.wr_cat_influxDB.addMeasurement(
                            bucket=bucket,
                            name_point=name_point,
                            fields=fields,
                           	tags=tags, 
							timestamp= timestamp)
			print("DataProcess -> Misure salvate su influx")
		except Exception as exception:
			print("ERRORE - DataProcess - Load Process Data FAILED")


	def Dummy_Process(self, factor = 1):    # scarica il dato e lo ricarica uguale
		# factor = -1
		kitID = -1
		self.process_is_on = True
		while self.process_is_on:
			print("FACCIO DATA PROCESS")
			fields = ["a"]
			data = self.Download_last_sample(kitID, fields)

			mapping = [(f, data[f] * factor) for f in fields]
			self.addMeasurements_InfluxDB(bucket=de.bucket_Io3_raw_data, name_point=kitID, fields=mapping)
			time.sleep(self.time_interval)

	# http://127.0.0.1:8088/set_status_base?state=1
	def Process_Base(self, factor=1):    # scarica il dato e lo ricarica uguale
		# factor = -1
		kitID = -1
		self.process_is_on = True
		while self.process_is_on:
			print("FACCIO DATA PROCESS")
			fields = ["a", "b", "c", "d", "e", "f", "g", "h"]
			data = self.Download_time_series(kitID, fields)

			# qua hai i dat scaricati
			timestamps = {f: [d[0] for d in data[f]] for f in fields}
			values = {f: [d[1] for d in data[f]] for f in fields}


			print(f"\n\n TIMESTAMPS: {timestamps}\n\n")
			print(f"\nVALUES: {values}\n\n")
			
			for i,t in  enumerate(timestamps['a']):
				mapping =  [(f, values[f][i] ) for f in fields] 
				self.addMeasurements_InfluxDB(
                                    bucket=de.bucket_Io3_raw_data, name_point=kitID, fields=mapping, timestamp=datetime.strptime(t, "%Y-%m-%d %H:%M:%S.%f%z"))

			fields = ["f"]
			data = self.Download_time_series(kitID, fields,bucket=de.bucket_Io3_raw_data,range_start="-1m")
			print("\n\nDOWNLOAD FROM SERVER")
			timestamps = {f: [d[0] for d in data[f]] for f in fields}
			values = {f: [d[1] for d in data[f]] for f in fields}
			print(f"TIMESTAMPS: {timestamps}\n\n")
			print(f"\nVALUES: {values}\n\n")
			time.sleep(self.time_interval)	

	# http://127.0.0.1:8088/set_status_kpi?state=1
	def Process_KPI(self, factor=1):    # scarica il dato e lo ricarica uguale

		def op_tmp_adding(df):
			op_tmp_list = []
			for index, row in df.iterrows():
				op_tmp_list.append((row['tmp'] + row['mrt']) / 2)
			return op_tmp_list

		# factor = -1
		kitID = -1
		self.process_is_on = True


		while self.process_is_on:
			print("FACCIO DATA PROCESS")
			fields = ["a", "b", "c", "d", "e", "f", "g", "h"]
			data = self.Download_time_series(kitID, fields,bucket=de.bucket_Io3_raw_data, range_start="-1h")
			
			


			# PARTE GIUSE
			timestamps = {f: [d[0] for d in data[f]] for f in fields}
			values = {f: [d[1] for d in data[f]] for f in fields}

			df_data = []
			i = 0
			while i < len(values['a']):
				row = []
				for f in fields:
					row.append(values[f][i])
				row.append(timestamps['a'][i])
				df_data.append(row)
				i += 1

			df = pd.DataFrame(df_data, columns=
			['tmp', 'hum', 'pm10', 'co2', 'wind_speed', 'acoustic', 'light', 'mrt', 'date'])
			df['tmp_op'] = op_tmp_adding(df)


			'''fields_long = ["d","f" ]
			data_long = self.Download_time_series(kitID, fields_long,bucket=de.bucket_Io3_raw_data, range_start="-6h")
			timestamps_long = {f: [d[0] for d in data_long[f]] for f in fields_long}
			values_long = {f: [d[1] for d in data_long[f]] for f in fields_long}
			df_data_long = []
			i = 0
			while i < len(values_long['d']):
				row = []
				for f in fields_long:
					row.append(values_long[f][i])
				row.append(timestamps_long['d'][i])
				df_data_long.append(row)
				i += 1

			df_long = pd.DataFrame(df_data_long, columns=['co2', "acoustic", 'date'])
			df_long['tmp_op'] = op_tmp_adding(df_long)
			'''


			if len(df["tmp_op"]) != 0:

				# calc = ComfortCalculator(df, df_long, kitID)
				calc = ComfortCalculator(df, kitID)
				data_to_send = calc.main_run()

				print('\n\nDATA TO SEND : ', data_to_send)
				print('\n\n')
				tags = [("kitID", kitID)]

				self.addMeasurements_InfluxDB(
					bucket=de.bucket_Io3_raw_data, name_point=de.kitID, fields=data_to_send, tags = tags)
				print('TIMESTAMP : ', datetime.now())
			else:
				pass
		
			#messaggio = str(random.randint(1, 3))
			messaggio = ""
			vett = [float(v) for (k, v) in data_to_send if k == "i"]
			if len(vett) == 0:
				messaggio = "0" # blu nel caso di errore riscontrato
			else:
				tot_comfort = vett[0]
				if tot_comfort < 33:
					messaggio = "1"  # rosso
				elif tot_comfort >= 33 and tot_comfort < 66:
					messaggio = "2"  # giallo
				else:
					messaggio = "3"  # verde
			
			print(f"MEssaggio status to Kit {messaggio}")
			self.client.publish(self.topic, messaggio)
			print("Messaggio MQTT inviato")



			time.sleep(self.time_interval)		

	def OPTIONS(self, *uri, **param):
		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])
		return "OK"

	@cherrypy.tools.json_out()
	def GET(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])

		# URI ALLOWED
		if (uri, list(param.keys()),) == deMS.main:
			return f"DataProcess -> mainPage -> correct built-in -> OK"
		else:
			print("ERRORE: URI NON PRESENTE -> se stai settando un valore ricordati di usare il PUT")

			# per far ritornare un file di testo HTML
			cherrypy.response.headers['Content-Type'] = 'text/html'
			return f"<p> Page Not Found -> Uri or parameters not correct </p> {self.uris_available}"

	@cherrypy.tools.json_in()
	@cherrypy.tools.json_out()
	def PUT(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])

		if (uri, list(param.keys()),) == deMS.set_status:
			if int(param[deMS.state]) == 0:
				print("Autogenerazioni dati - SPENTO")
				self.process_is_on = False
			elif int(param[deMS.state]) == 1:
				print("Autogenerazioni dati - ACCESO")
				# ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la
				# OLD -> self.autoGenerateData = threading.Thread(target=self.sens_fittizio_default.generate_and_send_data, name=setting[de.name], args=("127.0.0.6", "8086", "1", self.ID))
				self.autoGenerateData = threading.Thread(
					target=self.Dummy_Process, name=setting[de.name])
				self.autoGenerateData.start()
			else:
				print("ERRORE NEL SET DELLO STATE")
			return 0
		elif (uri, list(param.keys()),) == deMS.set_status_base:
			if int(param[deMS.state]) == 0:
				print("Autogenerazioni dati - SPENTO")
				self.process_base_is_on = False
			elif int(param[deMS.state]) == 1:
				print("Autogenerazioni dati - ACCESO")
				# ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la
				# OLD -> self.autoGenerateData = threading.Thread(target=self.sens_fittizio_default.generate_and_send_data, name=setting[de.name], args=("127.0.0.6", "8086", "1", self.ID))
				self.autoGenerateData = threading.Thread(
					target=self.Process_Base, name=setting[de.name])
				self.autoGenerateData.start()
			else:
				print("ERRORE NEL SET DELLO STATE")
			return 0
		elif (uri, list(param.keys()),) == deMS.set_status_kpi:
			if int(param[deMS.state]) == 0:
				print("Autogenerazioni dati - SPENTO")
				self.process_kpi_is_on = False
			elif int(param[deMS.state]) == 1:
				print("Autogenerazioni dati - ACCESO")
				# ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la
				# OLD -> self.autoGenerateData = threading.Thread(target=self.sens_fittizio_default.generate_and_send_data, name=setting[de.name], args=("127.0.0.6", "8086", "1", self.ID))
				self.autoGenerateData = threading.Thread(
					target=self.Process_KPI, name=setting[de.name])
				self.autoGenerateData.start()
			else:
				print("ERRORE NEL SET DELLO STATE")
			return 0
		else:
			print("ERROR URI DELETE NOT PRESENT")
			# per far ritornare un file di testo HTML
			cherrypy.response.headers['Content-Type'] = 'text/html'
			return f"<p> Page Not Found -> Uri or parameters not correct </p> {self.uris_available}"

	@cherrypy.tools.json_out()
	def DELETE(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])

		# URI ALLOWED
		return "Page Not Found -> Uri or parameters not correct"

	@cherrypy.tools.json_out()
	def POST(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])
		# URI ALLOWED
		return "Page Not Found -> Uri or parameters not correct"


if __name__ == "__main__":
	# TODO: Ricambia il path
	# settings_path = "./ms_dataprocess/settings.json"
	settings_path = "./ms_dataprocess/settings.json"
	setting = json.load(open(settings_path))

	static_dir = os.path.dirname(os.path.abspath(__file__))
	conf = {
		'/': {
			'request.dispatch': cherrypy.dispatch.MethodDispatcher(),
			'tools.sessions.on': True,
			#'tools.staticdir.root':os.path.abspath(os.getcwd())   # ORIGIANL
			'tools.staticdir.root': static_dir
		}
	}

	cherrypy.tree.mount(DataProcess( settings = setting), '/', conf)

	cherrypy.config.update(
		{'server.socket_host': setting[de.localhost], 'server.socket_port': setting[de.port]})

	de.print_name_cmd_2_lines()
	cherrypy.engine.start()
	cherrypy.engine.block()
