# 400 lines

from logging import raiseExceptions
import sys
import threading
import time

import requests
import defineVariable as deVar
import numpy as np
import cherrypy_cors
import json
import cherrypy
import os
import os.path
from datetime import datetime

import Sensore_Fittizio as sf

import defineURIMicroservices as deMicroServices
deMS = deMicroServices.de_microservices()

de = deVar.de()

#sys.path.append('D:\\POLITECNICO\\Magistrale\\A_IP\\project\\codice')
sys.path.append(os.path.abspath(os.getcwd()))
from communication_service_catalogue import ServiceCatalogueCommunication


class RESTSensorService:
	exposed = True

	def __init__(self, settings, main_ip, main_port):
		self.ID = settings[de.sensorID]
		self.locaityID = settings[de.localityID]
		self.uris_available = deMS.show_allUris()

		self.main_ip = main_ip
		self.main_port = main_port

		self.sensors:dict[str ,sf.SensoreFittizio] = {}
		for k,v in settings[de.info].items():
			self.sensors[k]:sf.SensoreFittizio = sf.SensoreFittizio(v[de.value], v[de.min], v[de.max], v[de.variance], v[de.maxIncrement])


		'''self.t = False
		self.h = False
		self.d = False

		if de.temperature in settings[de.info].keys():
			self.temperature = sf.SensoreFittizio(settings[de.info][de.temperature][de.value], settings[de.info][de.temperature][de.min],
                                        settings[de.info][de.temperature][de.max], settings[de.info][de.temperature][de.variance], settings[de.info][de.temperature][de.maxIncrement])
			self.t = True
		if de.humidity in settings[de.info].keys():
			self.humidity = sf.SensoreFittizio(settings[de.info][de.humidity][de.value], settings[de.info][de.humidity][de.min], settings[de.info][de.humidity]
                                     [de.max], settings[de.info][de.humidity][de.variance], settings[de.info][de.humidity][de.maxIncrement])
			self.h = True
		if de.deep in settings[de.info].keys():
			self.deep = sf.SensoreFittizio(settings[de.info][de.deep][de.value], settings[de.info][de.deep][de.min],
                                 settings[de.info][de.deep][de.max], settings[de.info][de.deep][de.variance], settings[de.info][de.deep][de.maxIncrement])
			self.d = True
			'''
		self.sens_fittizio_default = sf.SensoreFittizio(20, 15,25)
		self.autoGenerateData = threading.Thread(target=self.sens_fittizio_default.generate_and_send_data, name=setting[de.name], args=("127.0.0.6","8086", "1", self.ID))  # ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la 
		
		self.autoGenerateData = threading.Thread(target=self.SendDataToCloud, name=setting[de.name])
		#self.autoGenerateData.start()

		# PER FAR PARTIRE LA SIMULAZIONE DI UN SOLO KIT:
		# http://127.0.0.8:8088/1/set_state_process?state=1

	def CreateJSONData(self):
		'''
		IDEA DI FORMATTAZIONE
		{
			“kitID”: 1,
			“timestamp” : 2023-12-12 00:00:00,
			“data”: {
				“a”: 20,     -> misurazione a = temperature
				“b”: 40,
				....
			}
		}'''
		data = {}
		data["data"] = {}
		print(f"\n\nCreo JSON DATA - KitID: {self.ID}")
		for k,v in self.sensors.items():
			data["data"][k] = v.GenerateNewMeasurement()
		# aggiungo tag per identificare il tag
		data["kitID"] = self.ID 
		data[de.timestamp] = str(datetime.now())
		print(data)
		return data

	def SendDataToCloud(self):
		# PRIMA SEZIONE PER REGISTRARSI AL CATALOGO
		try:
			cloud_cat_ip, cloud_cat_port = "127.0.0.1", "8086"
			# per comoditá non le richiedo ogni volta
			#resource_cat_ip, resource_cat_port = ServiceCatalogueCommunication.GetIpandPort("resource_catalog")
			self.process_is_on = True
			while self.process_is_on:
				requests.put(f'http://{cloud_cat_ip}:{cloud_cat_port}/{self.locaityID}/history/new_influxDB?cks= 1',
				             json=self.CreateJSONData())
				print("-", end="")
				time.sleep(5)
		except:
			print(f"Sending data to Cloud FAILED")
			#raiseExceptions(f"Sending data to Cloud FAILED")

	def OPTIONS(self, *uri, **param):
		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])
		return "OK"

	@cherrypy.tools.json_out()
	def GET(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])

		# URI ALLOWED
		if (uri, list(param.keys()),) == deMS.main:
			return f"{self.ID} -> mainPage -> correct built-in -> OK"
		elif (uri, list(param.keys()),) == deMS.GetDataFromSersor:
			data = {}
			print("Richiedo DATA")
			for k,v in self.sensors.items():
				data[k] = v.GenerateNewMeasurement()

			'''if self.t:
				data[de.t] = self.temperature.GenerateNewMeasurement()
				#data["t"] = self.temperature.ReturnMeasure()
			if self.h:
				data[de.h] = self.humidity.GenerateNewMeasurement()
				#data["h"] = self.humidity.ReturnMeasure()
			if self.d:
				data[de.d] = self.deep.GenerateNewMeasurement()
				#data["d"] = self.deep.ReturnMeasure()'''
			#TODO bisogna togliere il timestamp perché non abbiamo un RTC su ogni sensore,
			# l'informazione sul tempo é inserita dal mainCenter chiedendo lui le misure,
			# e aggiungendo lui il timestamp al gruppo di misure
			data[de.timestamp] = str(datetime.now())
			print(data)
			return data
		else:
			print("ERRORE: URI NON PRESENTE -> se stai settando un valore ricordati di usare il PUT")

			# per far ritornare un file di testo HTML
			cherrypy.response.headers['Content-Type'] = 'text/html'
			return f"<p> Page Not Found -> Uri or parameters not correct </p> {self.uris_available}"

	@cherrypy.tools.json_in()
	@cherrypy.tools.json_out()
	def PUT(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])

		if (uri, list(param.keys()),) == deMS.setStateProcess:
			if int(param[deMS.state]) == 0:
				print("Autogenerazioni dati - SPENTO")
				self.process_is_on = False
			elif int(param[deMS.state]) == 1:
				print("Autogenerazioni dati - ACCESO")
				# ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la
				# OLD -> self.autoGenerateData = threading.Thread(target=self.sens_fittizio_default.generate_and_send_data, name=setting[de.name], args=("127.0.0.6", "8086", "1", self.ID))
				self.autoGenerateData = threading.Thread(target=self.SendDataToCloud, name=setting[de.name])
				self.autoGenerateData.start()
			else:
				print("ERRORE NEL SET DELLO STATE")
			return 0
		else:
			print("ERROR URI DELETE NOT PRESENT")
			# per far ritornare un file di testo HTML
			cherrypy.response.headers['Content-Type'] = 'text/html'
			return f"<p> Page Not Found -> Uri or parameters not correct </p> {self.uris_available}"


	@cherrypy.tools.json_out()
	def DELETE(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])

		# URI ALLOWED
		return "Page Not Found -> Uri or parameters not correct"

	@cherrypy.tools.json_out()
	def POST(self, *uri, **param):
		print("URL from cherrypy: " + str(cherrypy.url()))
		print("PARAM from cherrypy: " + str(param))
		print("PARAM.keys from cherrypy: " + str(list(param.keys())))
		print(uri)
		cherrypy.response.headers['Access-Control-Allow-Origin'] = '*'
		#cherrypy.response.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
		cherrypy.response.headers['Access-Control-Allow-Headers'] = "append,delete,entries,foreach,get,has,keys,set,values,Authorization"
		cherrypy.response.headers['Access-Control-Allow-Methods'] = "POST, GET, OPTIONS, DELETE, PUT"

		cherrypy.response.status = 200
		cherrypy_cors.preflight(allowed_methods=['GET', 'POST', 'OPTIONS'])
		# URI ALLOWED
		return "Page Not Found -> Uri or parameters not correct"


class RESTSensorServiceDefault():
	exposed = True

	def __init__(self, s):
		self.status = s
		pass
	def GET(self, *uri, **param):
		if (uri, list(param.keys()),) == deMS.main:
			if self.status:
				return "OK"
			else:
				return "ERROR PAGE -> CARICAMENTO SENSORI NON RIUSCITO -> alcuni IDs si ripetono"
		return "ERROR PAGE -> microservizio non caricato correttamente"

if __name__ == "__main__":

	settings_path = "./simulation/sensors/settings.json"
	setting = json.load(open(settings_path))
    # appendo il log automatico dopo ogni X secondi al service Catalog
	# process Retrieve Data
	scc = ServiceCatalogueCommunication(settings_path)
	
	updateResourceCatalog = threading.Thread(target=scc.ping_service_catalogue, name=setting[de.name])  # ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la 
	# PING DISATTIVATO 
	'''updateServiceCatalog.start()'''

    # parte dedicata a MQTT (se necessaria per i sensori)
    
    
    
    # parte dedicata a REST
    
	# Root static dir is this file's directory.
	static_dir = os.path.dirname(os.path.abspath(__file__))
	conf = {
		'/': {
			'request.dispatch': cherrypy.dispatch.MethodDispatcher(),
			'tools.sessions.on': True,
			#'tools.staticdir.root':os.path.abspath(os.getcwd())   # ORIGIANL
			'tools.staticdir.root': static_dir
		}
	}
	# instanzio primo sensore
	setting = json.load(open(settings_path))
	tutto_ok = False
	# bisogna trovare il modo di cambiare l'uri dove si trova il sensore una volta che é stato inizializzato correttamente 
	# devo prima verificare se ho 2 sensorID uguale
	if len(np.unique([s[de.sensorID] for s in setting[de.sensors]])) != len(setting[de.sensors]):
		print("error loading the sensorIDs -> there is a repetition of the same sensorID")
	else:
		for ind,s in enumerate(setting[de.sensors]):
			cherrypy.tree.mount(RESTSensorService(s, setting[de.main_ip], setting[de.main_port]), f'/{s[de.sensorID]}', conf)
			settings_path = "./simulation/sensors/settings.json"
			# appendo il log automatico dopo ogni X secondi al service Catalog
			# process Retrieve Data
			scc_dev = ServiceCatalogueCommunication(settings_path)
			# ricordarsi che non ci vanno i parametri , é come se fosse un altro main doe devi andarti a prendere le info direttamente da la
			updateResourceCatalog = threading.Thread(target=scc_dev.ping_device_catalogue, name=f'dev_{s[de.sensorID]}', args=(s["localityID"],s[de.sensorID],))
			# PING RESOURCE CATALOG DISATTIVATO
			#updateResourceCatalog.start()
		tutto_ok = True
	
	cherrypy.tree.mount(RESTSensorServiceDefault(tutto_ok), '/', conf)
		
	cherrypy.config.update(
		{'server.socket_host': setting[de.localhost], 'server.socket_port': setting[de.port]})
	de.print_name_cmd_2_lines()
	cherrypy.engine.start()
	cherrypy.engine.block()
